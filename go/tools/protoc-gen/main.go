package main

import (
	"log"
	"os"
	"path/filepath"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	// 创建protogen选项
	options := protogen.Options{
		ParamFunc: func(name, value string) error {
			// 处理命令行参数
			return nil
		},
	}

	// 运行代码生成器
	options.Run(func(gen *protogen.Plugin) error {
		// 支持可选字段
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		
		// 处理每个proto文件
		for _, file := range gen.Files {
			if !file.Generate {
				continue
			}
			
			// 生成Go代码
			if err := generateGoCode(gen, file); err != nil {
				return err
			}
			
			// 生成Rust代码（如果需要）
			if err := generateRustCode(gen, file); err != nil {
				return err
			}
		}
		
		return nil
	})
}

func generateGoCode(gen *protogen.Plugin, file *protogen.File) error {
	// 确定输出文件名
	goPackage := file.Proto.GetOptions().GetGoPackage()
	if goPackage == "" {
		log.Printf("Warning: no go_package option in %s", file.Desc.Path())
		return nil
	}
	
	outputDir := filepath.Dir(goPackage)
	baseName := filepath.Base(file.Desc.Path())
	outputFile := filepath.Join(outputDir, baseName+".pb.go")
	
	// 创建输出文件
	g := gen.NewGeneratedFile(outputFile, file.GoImportPath)
	
	// 生成代码头
	g.P("// Code generated by protoc-gen-nfa. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// \tprotoc-gen-nfa v0.1.0")
	g.P("// \tprotoc        ", protocVersion())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	
	// 生成导入语句
	g.P("import (")
	g.P("\t\"context\"")
	g.P("\t\"fmt\"")
	g.P()
	g.P("\t\"google.golang.org/grpc\"")
	g.P("\t\"google.golang.org/grpc/codes\"")
	g.P("\t\"google.golang.org/grpc/status\"")
	g.P("\t\"google.golang.org/protobuf/proto\"")
	g.P(")")
	g.P()
	
	// 生成消息类型
	for _, message := range file.Messages {
		generateMessage(g, message)
	}
	
	// 生成服务代码
	for _, service := range file.Services {
		generateService(g, service)
	}
	
	return nil
}

func generateRustCode(gen *protogen.Plugin, file *protogen.File) error {
	// 检查是否需要生成Rust代码
	rustPackage := getRustPackageOption(file)
	if rustPackage == "" {
		return nil
	}
	
	// 确定输出文件名
	baseName := filepath.Base(file.Desc.Path())
	outputFile := filepath.Join("crates/nfa-broker/src/generated", baseName+".rs")
	
	// 创建输出文件
	g := gen.NewGeneratedFile(outputFile, protogen.GoImportPath(rustPackage))
	
	// 生成Rust代码头
	g.P("// Code generated by protoc-gen-nfa. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// \tprotoc-gen-nfa v0.1.0")
	g.P("// \tprotoc        ", protocVersion())
	g.P()
	g.P("#![allow(dead_code)]")
	g.P("#![allow(unused_imports)]")
	g.P()
	g.P("use tonic::{{prelude::*, transport::Channel}};")
	g.P("use serde::{{Deserialize, Serialize}};")
	g.P()
	
	// 生成Rust消息类型
	for _, message := range file.Messages {
		generateRustMessage(g, message)
	}
	
	// 生成Rust服务代码
	for _, service := range file.Services {
		generateRustService(g, service)
	}
	
	return nil
}

func generateMessage(g *protogen.GeneratedFile, message *protogen.Message) {
	// 实现消息类型的生成
	g.P("// ", message.Desc.Name(), " 消息定义")
	g.P("type ", message.GoIdent, " struct {")
	for _, field := range message.Fields {
		g.P("\t", field.GoName, " ", goType(g, field))
	}
	g.P("}")
	g.P()
	
	// 生成方法
	g.P("func (x *", message.GoIdent, ") Reset() {")
	g.P("\t*x = ", message.GoIdent, "{}")
	g.P("}")
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	// 实现服务代码的生成
	g.P("// ", service.Desc.Name(), " 客户端定义")
	g.P("type ", service.GoName, "Client struct {")
	g.P("\tcc grpc.ClientConnInterface")
	g.P("}")
	g.P()
	
	// 生成客户端构造函数
	g.P("func New", service.GoName, "Client(cc grpc.ClientConnInterface) ", service.GoName, "Client {")
	g.P("\treturn ", service.GoName, "Client{cc}")
	g.P("}")
	g.P()
	
	// 生成客户端方法
	for _, method := range service.Methods {
		generateClientMethod(g, service, method)
	}
	
	// 生成服务端接口
	g.P("// ", service.Desc.Name(), " 服务端接口")
	g.P("type ", service.GoName, "Server interface {")
	for _, method := range service.Methods {
		g.P("\t", method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()
	
	// 生成服务端注册函数
	g.P("func Register", service.GoName, "Server(s grpc.ServiceRegistrar, srv ", service.GoName, "Server) {")
	g.P("\ts.RegisterService(&", service.GoName, "_ServiceDesc, srv)")
	g.P("}")
	g.P()
}

// 辅助函数
func goType(g *protogen.GeneratedFile, field *protogen.Field) string {
	// 实现Go类型映射
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(field.Enum.GoIdent)
	default:
		return "interface{}"
	}
}

func protocVersion() string {
	// 获取protoc版本
	return "3.21.12" // 假设的版本号
}

func getRustPackageOption(file *protogen.File) string {
	// 从proto文件选项中获取Rust包名
	for _, option := range file.Proto.Options.ProtoReflect().Range() {
		if option.Descriptor().FullName() == "rust_package" {
			return option.String()
		}
	}
	return ""
}

// Rust代码生成函数（简化实现）
func generateRustMessage(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("#[derive(Debug, Clone, Serialize, Deserialize)]")
	g.P("pub struct ", message.Desc.Name(), " {")
	for _, field := range message.Fields {
		g.P("\tpub ", field.Desc.JSONName(), ": ", rustType(field), ",")
	}
	g.P("}")
	g.P()
}

func generateRustService(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("#[tonic::async_trait]")
	g.P("pub trait ", service.Desc.Name(), ": Send + Sync + 'static {")
	for _, method := range service.Methods {
		g.P("\tasync fn ", method.Desc.Name(), "(")
		g.P("\t\t&self,")
		g.P("\t\trequest: tonic::Request<", method.Input.Desc.Name(), ">,")
		g.P("\t) -> Result<tonic::Response<", method.Output.Desc.Name(), ">, tonic::Status>;")
	}
	g.P("}")
	g.P()
}

func rustType(field *protogen.Field) string {
	// 实现Rust类型映射
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "String"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "i32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "i64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "u32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "u64"
	case protoreflect.FloatKind:
		return "f32"
	case protoreflect.DoubleKind:
		return "f64"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.BytesKind:
		return "Vec<u8>"
	case protoreflect.MessageKind:
		return field.Message.Desc.Name()
	case protoreflect.EnumKind:
		return field.Enum.Desc.Name()
	default:
		return "()"
	}
}